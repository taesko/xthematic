import os
import subprocess

import xrp
import xrp.parser

import xthematic.colors
import xthematic.config
import xthematic.term

AUTO_GENERATED_TEMPLATE = (
    "! auto generated colors from xthematic\n"
    "!\n"
    "!\n"
    "{}\n"
    "! xthematic end\n"
)


def save_terminal_colors(theme_name, overwrite=False):
    theme_file = xthematic.config.USER_THEME_DIR / theme_name
    if theme_file.exists() and not overwrite:
        raise FileExistsError(r'there already exists a theme {theme_name!r}')
    colors_string = (resource_string(color_id, xthematic.term.TERMINAL_COLORS[color_id], nl=True)
                     for color_id, color in xthematic.term.TERMINAL_COLORS.items())
    string = AUTO_GENERATED_TEMPLATE.format(''.join(colors_string))
    try:
        with theme_file.open(mode='w') as f:
            f.write(string)
    except Exception:
        if theme_file.exists():
            os.remove(theme_file)
        raise


def activate_theme(name, permanent=True, link_file=None):
    """
    :param name: name of the theme file in xthematic.config.USER_THEME_DIR
    :param permanent: boolean flag whether the resources should be loaded and
    the theme included in the ~/.Xresources file
    :param link_file: a link_file to configure pointing to the theme file. Does not modify
    the ~/.Xresources file if parameter is present.
    :return: None
    """
    activate_theme_in_terminal(name)
    if permanent:
        if link_file:
            tmp = backup_file_path(file_path=link_file)
            os.symlink(xthematic.config.USER_THEME_DIR / name, tmp)
            os.rename(src=tmp, dst=link_file)
            subprocess.check_call(['xrdb', '-load', xthematic.config.USER_XRESOURCES_FILE])
        else:
            include_theme_in_resources(name, xthematic.config.USER_XRESOURCES_FILE)
            include = '-I' + str(xthematic.config.USER_THEME_DIR)
            subprocess.check_call(['xrdb', include, '-load', xthematic.config.USER_XRESOURCES_FILE])


def remove_theme(name):
    t = xthematic.config.USER_THEME_DIR / name
    if t.exists():
        os.remove(t)
    else:
        raise FileNotFoundError("can't remove a theme that doesn't exist.")


def include_theme_in_resources(name, resource_file):
    """ Includes a theme in a resource file using an include statement.

    A backup of the original resource file is left in the directory with a '.backup' suffix
    """
    theme_file = xthematic.config.USER_THEME_DIR / name
    if not theme_file.is_file():
        raise FileNotFoundError("theme file doesn't exist")
    incl_string = str(xrp.parser.XIncludeStatement(include_file=name))
    output_file = backup_file_path(resource_file, suffix='.out')
    with open(resource_file, mode='r') as input_:
        with open(output_file, mode='w') as out:
            for line in replace_auto_generated(stream=input_, new_value=incl_string):
                out.write(line)
    os.rename(resource_file, backup_file_path(resource_file, can_exist=True))
    os.rename(output_file, resource_file)


def activate_theme_in_terminal(name):
    for color_id, color in theme_colors(theme_name=name).items():
        # TODO activating a theme sets all of the themes colors as custom - perhaps rethink activation
        xthematic.term.TERMINAL_COLORS[color_id] = color


def all_themes():
    return os.listdir(xthematic.config.USER_THEME_DIR)


def theme_colors(theme_name):
    parsed = xrp.parse_file(xthematic.config.USER_THEME_DIR / theme_name)
    dct = {}
    for color_id in xthematic.colors.ColorIdentifier.all_resources():
        hex_code = parsed.resources['*' + color_id.resource_id]
        dct[color_id] = xthematic.colors.Color(hex_code)
    return dct


def resource_string(color_id, color, nl=True):
    s = f"*{color_id.resource_id}: {color.hex}"
    return s + '\n' if nl else s


def replace_auto_generated(stream, new_value):
    # filter the autogenerated template
    for filtered in filter_auto_generated(stream):
        yield filtered
    new_lines = AUTO_GENERATED_TEMPLATE.format(new_value)
    for line in new_lines:
        yield line


def filter_auto_generated(stream):
    stream = iter(stream)
    current_template_line = 0
    template_lines = AUTO_GENERATED_TEMPLATE.splitlines(keepends=True)
    # filter template start
    for line in stream:
        if line == template_lines[current_template_line]:
            if current_template_line == 2:
                break
            else:
                current_template_line += 1
        else:
            yield line
    # filter old value and template end
    for line in stream:
        if line == template_lines[-1]:
            break

    for leftover in stream:
        yield leftover


def backup_file_path(file_path, suffix='.backup', can_exist=False):
    """ Return file_path with a suffix that is guaranteed to be unique inside it's directory.

    If can_exists is True uniqueness won't be guaranteed.
    """
    if can_exist:
        return file_path.with_suffix(suffix)

    sid = str(hash(str(file_path)))
    for k in range(len(sid)):
        file_backup = file_path.with_suffix(suffix + sid[:k])
        if not file_backup.exists():
            return file_backup
    else:
        raise RuntimeError("wtf")
